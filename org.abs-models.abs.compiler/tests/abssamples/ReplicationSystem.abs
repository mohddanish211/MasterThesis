module ReplicationSystem.Products;

interface Client extends Node {
	ClientDataBase getClientDataBase();
}

interface ClientConnector extends Client {
	Unit setAcceptor(ServerAcceptor acceptor);
}

// CSP model SyncClient(n)
// Java class com.fredhopper.application.SyncClient
interface SyncClient extends Client, ClientStateMachine {
	[Far] ServerAcceptor getAcceptor();
	Unit incrementJob();
}

interface InternalClient extends SyncClient {
	/*	
	 * Existing java implementation does not have client id
	 * the notion of an identifier for each client is required
	 * since the ABS model should guarantee data
	 * consistency as well as deadlock freedom
	 */
	ClientId getId();
}

interface ConcurrentInternalClient extends InternalClient {
	Bool canGoTo(State state);
}

interface ClientStateMachine {

	/* view job { 
     *   call_ClientStateMachine.start s,
	 *   call_ClientStateMachine.boot b,
	 *   call_ClientStateMachine.waitToBoot wb,
	 *   call_ClientStateMachine.replicate r,
	 *   call_ClientStateMachine.waitToReplicate wr,
	 *   call_ClientStateMachine.end e
	 * }
 	 */
 	 
 	/*
	 * START  ::= s WB  
	 *   WB   ::= wb B
	 *          | wb E
	 *   B    ::= b WB 
	 *          | b WR
     *          | b E
     *   WR   ::= wr R
	 *          | wr WB
	 *          | wr E
     *   R    ::= r  WR
	 *          | wr WB
	 *          | wr E
	 *   E    ::= e
     */
	
	Unit waitToBoot();
	Unit boot();
	Unit start();
	Unit waitToReplicate();
	Unit replicate();
	Unit end();
}

// Java class com.fredhopper.replication.client.ClientReplicationJob
// Java class com.fredhopper.replication.client.ClientBootJob
interface ClientJob extends Worker  {

	/* view job { 
     *   resolve_ClientJob.registerReplicationItems r, 
     *   call_ClientJob.processFile p,
	 *   call_ClientJob.processContent c
	 * }
 	 */
 	 
 	/*
	 * Bool START.retVal; Int START.callNums; Int T.callNums;
     *
	 * START ::= r T     START.retVal = r.return; START.callNums = T.callNums; 
	 *   T   ::= p c T'    T.callNums = 2 + T'.callNums;
     *         | p T'      T.callNums = 1 + T'.callNums;
	 *         | /\        T.callNums = 0;
     */
 
    //@ invariant not(retVal) ==> callNums == 0; 
	
	Bool registerReplicationItems(CheckPoint checkpoint);
	
	/*
	 * CSP model ProcessCommand'
	 * com.fredhopper.replication.client.ClientReplicationJob.receiveItemFragment(DataInputStream, int, ClientReplicationItem)
	 */
	Maybe<FileSize> processFile(FileId id);
	Unit processContent(File file);
	Unit receiveSchedule();
}

// Tester
interface Tester { }

// Common Interfaces
interface Commandee { 
	[Atomic] Unit command(Command command);
}

interface Worker extends Commandee {
	/*	
	 * Existing java implementation does not have client id
	 * the notion of an identifier for each client is required
	 * since the ABS model should guarantee data
	 * consistency as well as deadlock freedom
	 */
	ClientId forClient();
}

// One can shut down a node or ask if the node has been shut down.
// Both client and server are nodes
interface Node {
	
	/* view shutdown { 
     *   call_Node.isShutdownRequested i, 
     *   call_Node.requestShutDown r
	 * }
 	 */
 	 
 	/*
	 * START ::= F       
	 *   F   ::= i F'    
     *         | r T'
	 *   T   ::= i T'    
     *         | r T'      
     */

	DataBase getDataBase();
	Bool isShutdownRequested();
	Unit requestShutDown();
}

// CSP model CoordinatorProcess
// Java class com.fredhopper.replication.server.SyncServerClientCoordinator
interface SyncServerClientCoordinator { 

	/* view coordinator { 
     *   call_SyncServerClientCoordinator.startReplicationUpdate s, 
     *   call_SyncServerClientCoordinator.finishReplicationUpdate f
	 * }
 	 */
 	 
 	/*
	 * START ::= S       START.threads = S.threads
	 *   S   ::= s S'    S.threads = insertElement(s.worker,S'.threads)
     *         | f S'    S.threads = remove(f.worker,S'.threads)
     *         | /\      threads = EmptySet
     */

	Unit process();
	
	//@ requires z = coordinator.threads();
	//@ ensures equals(z,insertElement(worker,coordinator.threads()));   
	Unit startReplicationUpdate(ConnectionThread worker);
	
	//@ requires z = coordinator.threads();
	//@ ensures equals(z,remove(worker,coordinator.threads()));   
	Unit finishReplicationUpdate(ConnectionThread worker);

	/*
	 * Indicate client specified by cid is finished its 
	 * replication session 
	 */	
	Unit finishClient(ClientId cid);
}

// unexposed interface for specification
interface SyncServerClientCoordinatorSpec 
extends SyncServerClientCoordinator {

    /* view coordSpec { 
     *   call_SyncServerClientCoordinatorSpec.refreshSnapShot r, 
     *   call_SyncServerClientCoordinatorSpec.clearSnapshot c
	 * }
 	 */
 	 
 	/*
	 * START ::= S       START.threads = S.threads
	 *   S   ::= s S'    S.threads = insertElement(s.worker,S'.threads)
     *         | s r S'  S.threads = insertElement(s.worker,S'.threads)
	 *         | f S'    S.threads = remove(f.worker,S'.threads)
     *         | f c S'  S.threads = remove(f.worker,S'.threads)
     *         | /\      threads = EmptySet
     */

	//@ requires size(coordSpec.threads()) == 1;
	Unit refreshSnapShot();
	
	//@ requires size(coordSpec.threads()) == 0; 
	Unit clearSnapshot();
}

interface InternalCoordinator {
	Unit process();
}

// CSP model AcceptorThreadRun(t)
// Java class com.fredhopper.replication.server.SyncServerAcceptorThread
interface ServerAcceptor {
	[Far] ConnectionThread getConnection(ClientJob job);
}

interface SyncServerAcceptor extends ServerAcceptor {

	/* view syncaccepthist { 
     *   resolve_ServerAcceptor.getConnection g,
     *   resolve_SyncServerAcceptor.isAcceptingConnection a, 
     *   call_SyncServerAcceptor.suspendConnection s,
  	 *	 call_SyncServerAcceptor.resumingConnection f
	 * }
 	 */
 	 
 	/*
	 * START ::= R       START.suspend = False;
	 *   R   ::= a R     a.retVal = ~ R.suspend; R.suspend = R.suspend; 
     *         | s S     R.suspend = True;
     *         | r R'    R.suspend = False;
     *         | g R'    g.retVal = new ConnectionThread(g.job); R.suspend = R'.suspend;
	 *   S   ::= a S     a.retVal = S.suspend; S.suspend = S.suspend; 
     *         | s S     S.suspend = True;
     *         | r R     S.suspend = False;
     *         | g S'    g.retVal = null; S.suspend = S'.suspend;
     */

	//@ ensures result == syncaccepthist.suspend();
	Bool isAcceptingConnection();
	
    //@ ensures syncaccepthist.suspend() == True;
	Unit suspendConnection();
	
    //@ ensures syncaccepthist.suspend() == False;
	Unit resumingConnection();
	
}

// Java class com.fredhopper.replication.server.ConnectionThread
// CSP model ConnectionThreadRun(n)
interface ConnectionThread extends Worker { }

// Exposes schedule for testing
interface ServerNode extends Node {
	ServerSchedule getSchedule();
}

// CSP model SyncServer(n)
// Java class com.fredhopper.application.SyncServer
// Java class com.fredhopper.replication.server.ReplicationSnapshot
interface SyncServer extends ServerNode { 
	SyncServerAcceptor getAcceptor();
	[Far] SyncServerClientCoordinator getCoordinator();
	[Near] ReplicationSnapshot getReplicationSnapshot();
}

interface InternalServer extends SyncServer {
	Unit debug();
}

interface ReplicationSnapshot {
	Unit refreshSnapshot(Bool refreshSnapshot);
	
	/*
	 * Cleaning replication snapshot 
	 */
	Unit clearSnapshot();
	Int getIndexingId();
	Set<ServerReplicationItem> getItems();
	
	/*
	 * Only exists at model level
	 */
	Bool hasUpdated();
	
}

/*
 * Represents an item to be replicated to 
 * the sync clients. Global for the SyncServer
 *
 * Items could be abstracted as data type 
 * but data types cannot be modified by deltas! 
 */
interface ServerReplicationItem {
	FileEntry getContents();
	Command getCommand();
	ReplicationItemType getType();
	FileId getAbsoluteDir();
	[Atomic] Unit refresh();
	[Atomic] Unit cleanup();
}

// CSP model ClientReplicationJob(n)
// Java class com.fredhopper.replication.client.ClientReplicationJob
class ClientJobImpl([Far] InternalClient client, JobType job) 
implements ClientJob {
	
	Command command = EndSnapShot;
	Bool hasSchedule = False;
	
	// A flag to see if new job should start
	Bool newJob = False;
	
	ConnectionThread thread = null;
	[Far] ClientDataBase db;
	
	ConnectionThread getConnectionThread() {
		Fut<ServerAcceptor> fs = client!getAcceptor();
		ServerAcceptor acceptor = fs.get;
		
		// Acquire a connection
		Fut<ConnectionThread> t = acceptor!getConnection(this); await t?;
		return t.get;
	}
	
	Unit setDb() {
		Fut<ClientDataBase> fd = client!getClientDataBase();
		this.db = fd.get;
	}
	
	// starts a replication job
	Unit scheduleNewJob() {
		await newJob;
		new local ClientJobImpl(this.client,Replication);
	}
	
	Unit run() {
		// set data base
		this.setDb();
	
		// Acquire a connection
		this.thread = this.getConnectionThread();
		if (thread != null) {
			// Connection successful!
			Fut<Unit> unit;
			if (this.job == Boot) {
				this.becomeState(Booting);
				
				this.thread!command(ListSchedule);
				await hasSchedule == True;
				
				//establish the next schedule triggers!
				this!scheduleNewJob();
				
			} else {
				this.becomeState(WorkOnReplicate);
				
				this.thread!command(SearchSchedule);
				await hasSchedule == True;
				
				//establish the next schedule triggers!
				this!scheduleNewJob();
				
				// wait for current job to start then end
				await command == StartSnapShot;
				await command == EndSnapShot;
			}
				
			this.becomeState(WaitToReplicate);
			
			unit = this.client!incrementJob();
			unit.get;
			
			//allow next job to proceed
			newJob = True;
			
		} else {
			// Connection unsuccessful! Perform shutdown 
			this.shutDownClient();
		}
	}
	
	Unit becomeState(State state) {
		if (state == WaitToBoot) {
			Fut<Unit> unit = this.client!waitToBoot(); unit.get;
		} else if (state == Booting) { 
			Fut<Unit> unit = this.client!boot(); unit.get;
		} else if (state == WorkOnReplicate) { 
			Fut<Unit> unit = this.client!replicate(); unit.get;
		} else if (state == WaitToReplicate) { 
			Fut<Unit> unit = this.client!waitToReplicate(); unit.get;
		} else if (state == End) { 
			Fut<Unit> unit = this.client!end(); unit.get;
		}
	}
	
	ClientId forClient() {
		Fut<ClientId> fut = client!getId();
		return fut.get;
	}
	
	Unit shutDownClient() {
		Fut<Unit> unit = client!requestShutDown(); unit.get;
		unit = this.client!end(); unit.get;
	}
	
	Bool registerReplicationItems(CheckPoint checkpoint) {
		Fut<Bool> reg = db!prepareReplicationItem(checkpoint);
		return reg.get;
	}
	
	Bool hasFile(FileId id) {
		Fut<Bool> he = db!hasFile(id); await he?;
		return he.get;
	}
	
	/*
	 * CSP model Register
	 * com.fredhopper.replication.client.ClientReplicationJob.receiveItemFragment(DataInputStream, int, ClientReplicationItem)
	 */
	Maybe<FileSize> processFile(FileId id) {
		Maybe<FileSize> result = Nothing;
		Fut<Set<FileId>> fs = db!listFiles();
		Set<FileId> fids = fs.get;
		if (contains(fids,id)) {
			Bool he = this.hasFile(id);
			if (he) {
				Fut<FileContent> contentf = db!getContent(id); await contentf?;
				FileContent content = contentf.get; 
				if (isFile(content)) {
					FileSize size = content(content);
					result = Just(size);				
				}
			}
		}
		return result;
	}  
	
	Unit overwrite(File file) {
		FileId id = fst(file);
		FileSize size = fileContent(file);
		Fut<Unit> u = db!updateFile(id,size); await u?;
	}
	
	Unit continue(File file) {
		FileId id = fst(file);
		FileSize size = fileContent(file);
		
		Bool he = this.hasFile(id);
		FileSize fsize = 0;
		if (he) {
			Fut<FileContent> s = db!getContent(fst(file)); await s?;
			FileContent c = s.get;
			fsize = content(c);		
		}
		
		size = size + fsize;
		Fut<Unit> u = db!updateFile(id,size); await u?;
	}
	
	Unit processContent(File file) {
		await isAppendCommand(command);
		if (command == SkipFile) {
			skip;
		} else if (command == OverwriteFile) {
			this.overwrite(file);
		} else if (command == ContinueFile) {
 			this.continue(file);
		}
	}  
	
	[Atomic] Unit command(Command c) { 
		command = c; 
	}
	
	Unit receiveSchedule() { hasSchedule = True; }
	
	Int getId() { return 1; }
}

// Implementation of SyncClient 
// Java class com.fredhopper.application.SyncClient
[COG] class SyncClientImpl(ClientId id) 
implements InternalClient, ClientConnector {
	
	Map<State,Set<State>> machine = map[];
	
	ServerAcceptor acceptor = null;
	ClientDataBase db = null;

	State state = Start;
	Int jobCount = 0;
	Bool shutDown = False;
	
	{
		// Defines possible transitions
		Pair<State,Set<State>> start = 			 Pair(Start, 			set[WaitToBoot]);
		Pair<State,Set<State>> waitToBoot = 	 Pair(WaitToBoot, 		set[Booting,End]);
		Pair<State,Set<State>> booting =		 Pair(Booting, 			set[WaitToBoot,WaitToReplicate,End]);
		Pair<State,Set<State>> waitToReplicate = Pair(WaitToReplicate, 	set[WaitToBoot,WorkOnReplicate,End]);
		Pair<State,Set<State>> workOnReplicate = Pair(WorkOnReplicate,	set[WaitToBoot,WaitToReplicate,End]);
		
		// Creates states machine
		this.machine = map[start,waitToBoot,booting,waitToReplicate,workOnReplicate];
	
		// initialize the client side data base
		this.db = new local DataBaseImpl(map[]);
	}
	
	ClientId getId() {
		return this.id;
	}
		
	Bool isShutdownRequested() {
		return this.shutDown;
	}
	
	Unit requestShutDown() {
		this.shutDown = True;
	}
		
	Unit incrementJob() {
		jobCount = jobCount + 1;
	}
	
	ServerAcceptor getAcceptor() {
		return this.acceptor;
	}
	
	Unit run() {
		// Makes a transition
		this.becomesState(WaitToBoot);
		
		// wait for acceptor to be ready
		await acceptor != null;
		
		this.incrementJob();
		
		// starts a boot job
		new ClientJobImpl(this,Boot);
	}
	
	ClientDataBase getClientDataBase() {
		return db;
	}
	
	DataBase getDataBase() {
		return db;
	}
	
	Unit becomesState(State state) {
		assert contains(lookupUnsafe(machine,this.state),state);
		this.state = state;	
	}
	
	Unit setAcceptor([Far] ServerAcceptor acc) {
		this.acceptor = acc;
	}
	
	Unit waitToBoot() { 
		this.becomesState(WaitToBoot);
	}
	
	Unit boot() { 
		this.becomesState(Booting);
	}
	
	Unit start() { 
		this.becomesState(Booting);
	}
	
	Unit waitToReplicate() { 
		this.becomesState(WaitToReplicate);
	}
	
	Unit replicate() { 
		this.becomesState(WorkOnReplicate);
	}
	
	Unit end() { 
		this.becomesState(End);
	}
	
		
}

def List<A> takeList<A>(List<A> ss,Int i) =
	case i {
		0 => Nil;
		_ => case ss {
				Nil => Nil;
				Cons(x,xs) => Cons(x,takeList(xs,i-1));
			}; 
	};

def Set<A> takeSet<A>(Set<A> ss,Int i) =
	case i {
		0 => set[];
		_ => case takeMaybe(ss) {
				Nothing => set[];
				Just(x) => insertElement(takeSet(remove(ss, x),i-1),x);
			}; 
	};
	
def Map<A,B> takeMap<A,B>(Map<A,B> mp,Int i) =
	case i {
		0 => map[];
		_ => case mp {
				EmptyMap => map[];
				InsertAssoc(x,xs) => insert(takeMap(xs,i-1), x);
			}; 
	};
	 
class Main {

	TestData datas = 
		map[Pair(1,
				map[file("dir1/file1",1),
					file("dir1/file2",2)]),
			Pair(2,
				map[file("dir2/file1",3),
					file("dir2/file2",4)]),
			Pair(3,
				map[file("dir1/file1",3),
					file("dir1/file2",4)]),
			Pair(4,
				map[file("dir3/file1",3),
					file("dir3/file2",4)]),
			Pair(5,
				map[file("dir2/dir21/file1",1),
					file("dir2/dir21/file2",2),
					file("dir2/dir22/file3",3),
					file("dir2/dir22/file4",4)])
		];
		
	Set<ClientId> cids = set[0,1];
	
	Unit run() {
		TestData items = this.getDatas();
		List<Schedule> schedules = this.getSchedules();
		Set<ClientId> cids = this.getCids();
		new local ReplicationSystem(takeMap(datas,1),takeList(schedules,1),set[0]);
		//new local ReplicationSystem(items,schedules,cids);
	}
	
	List<Schedule> getSchedules() {
		return list[SearchItem(rootPath()),SearchItem("dir3")];
	}
	
	TestData getDatas() {
		return datas;
	}
	
	Set<ClientId> getCids() {
		return cids;
	}
}

def Set<A> listToSet<A>(List<A> a) = set(a);


//ReplicationSystem simulator
class ReplicationSystem(
	Map<CheckPoint,Map<FileId,FileContent>> items, 
	List<Schedule> schedules,
	Set<ClientId> cids) {

	ServerSchedule setschedules = set[];
	
	Unit run() {
		// One SyncServer
		[Far] SyncServer syncserver = new SyncServerImpl(items,listToSet(schedules),cids);
		
		Set<[Far] ClientConnector> syncclients = set[];
		Set<[Far] Tester> testers = set[];
		
		Set<ClientId> iterator = cids;
		while (hasNext(iterator)) {
			Pair<Set<ClientId>,ClientId> nt = next(iterator);
			ClientConnector syncclient = new SyncClientImpl(snd(nt));
			syncclients = insertElement(syncclients,syncclient);
			
			Tester tester = new TesterImpl(syncserver,syncclient);
			testers = insertElement(testers,tester);
			iterator = fst(nt);
		}
		
		Fut<SyncServerAcceptor> acc = syncserver!getAcceptor(); await acc?;
		[Far] SyncServerAcceptor acceptor = acc.get;	
		
		Set<ClientConnector> clientIterator = syncclients;
		while (hasNext(clientIterator)) {
			Pair<Set<ClientConnector>,ClientConnector> nt = next(clientIterator);
			ClientConnector syncclient = snd(nt);
			syncclient!setAcceptor(acceptor);
			clientIterator = fst(nt);
		}
			
	}

} 

/*
 * Checks that the file store in the data base of the actual node
 * is the same as the file store in the data base of the expected node.  
 */
class TesterImpl(ServerNode expected, Node actual) implements Tester {
	
	ServerSchedule schedule = set[]; 
	Set<Triple<FileId,FileContent,FileContent>> result = set[];
	
	Unit run() {
		Bool shutdown = False;
		while (! shutdown) {
			Fut<Bool> sd = this.actual!isShutdownRequested(); await sd?; 
			shutdown = sd.get;
		}
		this.assertData();
	}
	
	Unit assertData() {
		Fut<DataBase> fe = this.expected!getDataBase();
		DataBase e = fe.get;
		
		Fut<ServerSchedule> schf = this.expected!getSchedule();
		this.schedule = schf.get;
		
		Fut<DataBase> fa = this.actual!getDataBase();
		DataBase a = fa.get;
		
		this.checkDatas(e,a);
	}
	
	Unit checkDatas(DataBase e, DataBase a) {
		//check against schedule!
		ServerSchedule ss = this.schedule;
		while (hasNext(ss)) {
			Pair<ServerSchedule,Schedule> ns = next(ss);
			this.checkData(snd(ns),e,a);
			ss = fst(ns); 
		}
	}
	
	Unit checkData(Schedule s, DataBase e, DataBase a) {
		if (isLeft(item(s))) {
			FileId id = left(item(s));
			Fut<FileContent> ccg = e!getContent(id); 
			FileContent ce = ccg.get; 
			
			Fut<FileContent> ccf = a!getContent(id); 
			FileContent ca = ccf.get; 
				
			if (isFile(ce)) {
				this.compareFile(file(id,content(ce)),file(id,content(ca)));
			} else {
				this.compareDir(dir(id,entries(ce)),dir(id,entries(ca)));
			}
		} 
	}
	
	Unit compareDir(Directory e, Directory a) {
		Set<FileId> fids = getFileIdFromDir(e);
		Set<FileId> eids = getFileIdFromDir(a);
		this.compareFiles(e,a,fids,eids);
	}
	
	Unit compareFiles(
		Directory e, Directory a, 
		Set<FileId> fids, Set<FileId> eids) {

		assert size(fids) == size(eids);
		while (hasNext(fids)) {
			Pair<Set<FileId>,FileId> nd = next(fids);
			FileId id = snd(nd);
			FileContent es = fromJust(getFromEntryIn(e,id));
			FileContent as = fromJust(getFromEntryIn(a,id));
			result = insertElement(result, Triple(id,es,as));
			assert(es == as);
			fids = fst(nd); 
		}
	}
	
	Unit compareFile(File e, File a) {
		FileId id = getFileId(Left(e));
		FileContent es = getFileContent(Left(e));
		FileContent as = getFileContent(Left(a));
		result = insertElement(result, Triple(id,es,as));
		assert(es == as);
	}
	
}

[Plain] class SyncServerAcceptorImpl([Near] InternalServer server) 
implements SyncServerAcceptor {
	
	// A flag representing com.fredhopper.replication.server.SyncServerAcceptorThread.waitForResumingSignal
	// A flag representing com.fredhopper.replication.server.SyncServerAcceptorThread.acceptingConnections
	Bool accept = True;

	Int threads = 0; // for debugging
	
	// Return a null thread if server is/has been shutting down
	ConnectionThread getConnection(ClientJob job) {
		ConnectionThread thread = null;
		
		// Shutdown flag	
		Bool shutdown = this.server.isShutdownRequested();
		if (! shutdown) {
			await accept;
			thread = new ConnectionThreadImpl(job,server,threads);
			threads = threads + 1; // for debugging
		} 
		
		return thread;
	}
	
	Bool isAcceptingConnection() {
		return accept;
	}
	
	Unit suspendConnection() {
		accept = False;
	}
	
	Unit resumingConnection() {
		accept = True;
	}
}

[COG] class ConnectionThreadImpl(
		[Far] ClientJob job, 
		[Far] InternalServer server, 
		Int id) implements ConnectionThread {

	SyncServerClientCoordinator coord;
	Maybe<Command> cmd = Nothing;
	
	Unit run() {
		Fut<SyncServerClientCoordinator> c = server!getCoordinator(); await c?;
		this.coord = c.get;
		
		// register and refresh snapshot
		Fut<Unit> rp = this.coord!startReplicationUpdate(this); await rp?;
		
		// wait for client's command
		await this.cmd != Nothing;
		
		// Send schedules
		rp = this.job!receiveSchedule(); await rp?;
		
		if (cmd != Just(ListSchedule)) {
	
			// Get replication items
			Fut<ReplicationSnapshot> sp = this.server!getReplicationSnapshot();
			ReplicationSnapshot snapshot = sp.get;
			
			Fut<CheckPoint> cpf = snapshot!getIndexingId(); await cpf?;
			CheckPoint cp = cpf.get;
			
			Fut<Bool> b = job!registerReplicationItems(cp); await b?;
			Bool register = b.get;
			
			Set<Set<File>> filesets = set[];
			if (register) {
				Fut<Set<ServerReplicationItem>> nis = snapshot!getItems(); await nis?;
				Set<ServerReplicationItem> newitems = nis.get;
				filesets = this.registerItems(newitems);
			}
			
			// start snapshot
			rp = this.job!command(StartSnapShot); await rp?;
			
			while (hasNext(filesets)) {
				Pair<Set<Set<File>>,Set<File>> nfs = next(filesets);
				filesets = fst(nfs);
				Set<File> fileset = snd(nfs); 
				this.transferItems(fileset);
			}
			
			// before ending snapshot replication
			// tell server this client has completed its session
			ClientId cid = this.forClient();
			
			// this is superfluous call! (waiting period)
			rp = this.server!debug(); await rp?;
			
			rp = this.coord!finishClient(cid); await rp?;
			
			// end snapshot		
			rp = this.job!command(EndSnapShot); await rp?;
		
		}
		
		rp = this.coord!finishReplicationUpdate(this); await rp?;
				
	}
	
	ClientId forClient() {
		Fut<ClientId> id = job!forClient();
		return id.get;
	}
	
	[Atomic] Unit command(Command c) { 
		this.cmd = Just(c); 
	}
	
	/*
	 * Register replication items with client 
	 * Returns a set of files to be replicated
	 */
	Set<Set<File>> registerItems(Set<ServerReplicationItem> items) {
		Set<Set<File>> regs = set[];	
	
		//iterate over possible check points
		while (hasNext(items)) {
			Pair<Set<ServerReplicationItem>,ServerReplicationItem> nis = next(items);
			items = fst(nis);
			ServerReplicationItem item = snd(nis);

			// For now convert to a set
			// will convert it into directory
			Fut<FileEntry> entryf = item!getContents(); await entryf?;
			FileEntry entry = entryf.get;
			
			Set<File> result = set[];
			Set<FileId> ids = getFileIdFromEntries1(entry);
			while (hasNext(ids)) {
				Pair<Set<FileId>,FileId> nids = next(ids);
				FileId id = snd(nids);
				Maybe<FileContent> content = getFromEntry(entry,id);
				result = insertElement(result, Pair(id,fromJust(content)));
				ids = fst(nids);
			}
			
			regs = insertElement(regs,result);
		}
		
		return regs;
	}
	
	Unit transferItems(Set<File> fileset) {
		while (hasNext(fileset)) {
			Pair<Set<File>,File> nf = next(fileset); 
			fileset = fst(nf);
			File file = snd(nf);
			FileSize tsize = fileContent(file);
			
			Fut<Unit> rp = job!command(AppendSearchFile); await rp?;
			Fut<Maybe<FileSize>> fs = job!processFile(fst(file)); await fs?;
			Maybe<FileSize> content = fs.get;
			
			FileSize size = 0;
			if (isJust(content)) { 
				size = fromJust(content);
			}
			
			if (size > tsize) {
				rp = job!command(OverwriteFile);
				await rp?;
				rp = job!processContent(file);
				await rp?;
			} else {
				// find out how much is still need to be replicated
				if (tsize - size > 0) {
					rp = job!command(ContinueFile);
					await rp?;
					
					file = file(fst(file),tsize - size);
					rp = job!processContent(file);
					await rp?;
				} else {
					rp = job!command(SkipFile);
					await rp?;
				}
			}

		}
		Fut<Unit> rp = job!command(EndSearchFile); await rp?;
	}
}

// CSP model CoordinatorProcess
// Java class com.fredhopper.replication.server.SyncServerClientCoordinator
[COG] class SyncServerClientCoordinatorImpl(
		[Far] SyncServer server,
		[Far] ReplicationSnapshot snapshot,
		Set<ClientId> clients) implements SyncServerClientCoordinatorSpec {
	
	Int count = 0;
	Maybe<CheckPoint> cps = Nothing;
	
	Bool shutDown = False;
	
	// Mimic internal choice
	Bool internal = False;
	
	SyncServerAcceptor acceptor = null;
	Set<ConnectionThread> threads = set[];
	
	// Keep track of current list of clients (used for invariant checking)
	Set<ClientId> currentClients = set[];
	
	//trace of clients activity
	//initialise with empty trace
	List<List<ClientId>> traces = Cons(Nil,Nil);
	
	Unit process() {
		Fut<Unit> unit;
	
		// get SyncServerAcceptor
		Fut<SyncServerAcceptor> fs = this.server!getAcceptor(); await fs?;
		this.acceptor = fs.get;
		
		Bool shutdown = this.isServerShutdownRequested();
		while (!shutdown) {
			//try polling on the return boolean value
			Fut<Bool> fd = acceptor!isAcceptingConnection(); await fd?;
			Bool accept = fd.get;
			
			// There is a consideration about how long 
			// a worker should have been working
			// This is abstracted in this model and 
			// so we use a flag to model this.
			if (accept) {
				if (! emptySet(threads) && internal) {
					unit = this.acceptor!suspendConnection(); await unit?;
					this.internal = False;
				} else {
					this.internal = True;
				}
			} else {
				if (emptySet(threads)) {
					unit = this.acceptor!resumingConnection(); await unit?;
				}
			}
			shutdown = this.isServerShutdownRequested();
		}
		
		// Shutdown sequence
		await threads == set[];
		unit = this.acceptor!resumingConnection(); await unit?;
	}
	
	Bool isServerShutdownRequested() {
		Fut<Bool> fd = this.server!isShutdownRequested(); await fd?;
		return fd.get;
	}
	
	// Setting up a replication session
	Unit startReplicationUpdate(ConnectionThread thread) {
		this.threads = insertElement(this.threads, thread);
		if (size(this.threads) == 1) {
			this.refreshSnapShot();
		}
	}
	
	// Tidy up after a replication session
	Unit finishReplicationUpdate(ConnectionThread thread) {
		if (contains(this.threads,thread)) {
			if (size(this.threads) == 1) {
				this.clearSnapshot();
			}
			this.threads = remove(this.threads,thread);
		}
	}
	
	Unit clearSnapshot() {
		Fut<Unit> unit = this.snapshot!clearSnapshot(); unit.get;
	}
 	
	Unit refreshSnapShot() {
		count = count + 1; //for debug

		Bool makeChange = this.isNotWaitingForMoreClient();
		
		// advance check point only after data 
		// has been replicated to all clients
		Fut<Unit> unit = this.snapshot!refreshSnapshot(makeChange); unit.get;
		
		// check point to see if any items has been reloaded
		CheckPoint cp = this.getCurrentCheckPoint();
		
		// check point to see if an update has happened
		Fut<Bool> rf = this.snapshot!hasUpdated();
		Bool up = rf.get;
		this.shutDown = !up;
		
		//reset the current client lists 
		//if refresh is successful and is not waiting
		//for more clients.
		if (makeChange) {
			if (this.cps == Nothing) {
				this.cps = Just(cp);
				this.traces = appendright(this.traces,Nil);
			} else if (cp > fromJust(this.cps)) {
				this.cps = Just(cp);
				this.traces = appendright(this.traces,Nil);
			}
			
			if (!this.shutDown) {
				this.currentClients = this.clients;
			} else {
				unit = this.server!requestShutDown(); unit.get;
			}
		}
		
	}
	
	ClientId getClientId([Far] ConnectionThread thread) {
		Fut<ClientId> fid = thread!forClient(); 
		return fid.get;
	}
	
	Unit removeClient(ConnectionThread thread) {
		ClientId id = this.getClientId(thread);
		this.currentClients = remove(this.currentClients,id);
	}
	
	Unit addClient(ConnectionThread thread) {
		ClientId id = this.getClientId(thread);
		assert !contains(this.currentClients,id);
		this.currentClients= insertElement(this.currentClients, id);
	}
	
	/*
 	 * We need to introduce a mechanism to determine
	 * the number of SyncClients that will be connected to 
	 * this implementation of the SyncServer
	 *
	 * Note that this method is not exposed through any interface
	 */
	Bool isNotWaitingForMoreClient() {
		return this.currentClients == set[];
	}
	
	CheckPoint getCurrentCheckPoint() {
		Fut<CheckPoint> cf = this.snapshot!getIndexingId();
		return cf.get;
	}
	
	/*
	 * Indicate client specified by cid is finished its 
	 * replication session 
	 */
	Unit finishClient(ClientId cid) {
		CheckPoint cp = this.getCurrentCheckPoint();
		this.currentClients = remove(this.currentClients,cid);
		assert length(this.traces) > cp - 1;
		this.traces = setAt(this.traces,appendright(nth(this.traces,cp-1),cid),cp-1);
	}
	
	Int getCount() {
		return this.count;
	}
}

class ReplicationSnapshotImpl(
	ServerDataBase db, 
	ServerSchedule schedules) implements ReplicationSnapshot {

	Int count = 0;
	Int update = 0;
	
	//cps increments after each time 
    //changes to be made to item store
	Bool updated = False;
	CheckPoint cps = 0;
	
	// if snapshot is cleaned
	Bool clean = True;
	
	Set<ServerReplicationItem> items = set[];
	
	Set<ServerReplicationItem> getItems() {
		return this.items;
	}
	
	/*
	 * Updating replication snapshot
	 * @param makeChange currently specifies whether to actually 'refresh'
	 */
	Unit refreshSnapshot(Bool makeChange) {
		count = count + 1; //for debug
		if (clean) {
			// advance check point only after data 
			// has been replicated to all clients
			if (makeChange) {
				this.cps = this.cps + 1;
			}
			
			updated = this.db.refresh(makeChange);
			if (updated) {
				update = update + 1; //for debug
				
				this.createReplicationItems();
				Set<ServerReplicationItem> titems = this.getItems();
				while (hasNext(titems)) {
					Pair<Set<ServerReplicationItem>,ServerReplicationItem> ni = next(titems);
					titems = fst(ni);
					ServerReplicationItem item = snd(ni);
					item.refresh();
				}

				clean = False;
			}
		}
		
	}
	
	Unit createReplicationItems() {
		ServerSchedule tsc = schedules;
		while (hasNext(tsc)) {
			Pair<ServerSchedule,Schedule> ns = next(tsc);
			this.replicationItem(snd(ns));
			tsc = fst(ns);
		}
	}
	
	[Modifies]
	Unit replicationItem(Schedule schedule) {
		if (isSearchItem(schedule)) {
			ServerReplicationItem item = new local SearchDirectoryItem(left(item(schedule)),this.db);
			this.items = insertElement(this.items, item);
		} 
		
		/*
		if (isFileItem(schedule)) { 
			// this will be defined in the deltas
			Pair<FileId,String> it = right(item(schedule));
			ServerReplicationItem item = new local ReplicationFilePattern(fst(it),snd(it),this.db);
			this.items = Insert(item,this.items);
		} 
		
		if (isLogItem(schedule)) { 
			// this will be defined in the deltas
			ServerReplicationItem item = new local ReplicationLogItem(left(item(schedule)),this.db);
			this.items = Insert(item,this.items);
		} 
		*/
	}
	
	//Clear snapshot
	Unit clearSnapshot() {
		this.items = set[];
		clean = True;
	}
	
	Bool hasUpdated() {
		return this.updated;
	}
	
	Int getIndexingId() {
		return this.cps;
	}

}

// @param qualified is an absolute path from 'root' in db
// @param db points to the database that stores the whole file structure and it responsible for update
class SearchDirectoryItem(FileId qualified, ServerDataBase db) 
implements ServerReplicationItem {

	Directory snapshot = emptyDir(rootPath());
	
	{
		this.cleanup();
	}  
	
	FileEntry getContents() {
		return dirContent(snapshot);
	}
	
	Command getCommand() { 
		return AppendSearchFile; 
	}
	
	ReplicationItemType getType() { 
		return SearchReplicationDirectory; 
	}
	
	FileId getAbsoluteDir() {
		return qualified;
	}
	
	[Atomic] Unit refresh() {
		// get all file names for the newest check points
		Set<FileId> fids = this.db.listCheckPointFiles();
		while (hasNext(fids)) {
			Pair<Set<FileId>,FileId> nt = next(fids);
			fids = fst(nt);
			FileId fid = snd(nt);
			
			// check if this file is in the item's directory
			if (isAncester(this.qualified,fid)) {
				FileContent content = this.db.getContent(fid);
				snapshot = updateDirWithContent(snapshot,fid,content);
			}
		}
	}
	
	[Atomic] Unit cleanup() {
		this.snapshot = updateDirWithDir(emptyDir(rootPath()),emptyDir(qualified)); 
	}
	
}

[COG] class SyncServerImpl(
		Map<CheckPoint,Map<FileId,FileContent>> datas,
		ServerSchedule schedules,
		Set<ClientId> clients) implements InternalServer, SyncServer {
	
	Bool shutDown = False;
	
	Int debug = 0; //for debugging
	
	[Far] SyncServerClientCoordinator coordinator = null;
	[Near] SyncServerAcceptor acceptor = null;
	[Near] ServerDataBase db = null;
	[Near] ReplicationSnapshot snapshot = null;
	
	{
		this.db = new local DataBaseImpl(datas);
		this.snapshot = new local ReplicationSnapshotImpl(this.db,this.schedules);
	}
	
	Unit run() {
		this.coordinator = new SyncServerClientCoordinatorImpl(this,snapshot,clients);
		this.acceptor = new local SyncServerAcceptorImpl(this);
		this.coordinator!process();
	}
	
	DataBase getDataBase() {
		return this.db;
	}
	
	ServerSchedule getSchedule() {
		return this.schedules;
	}
	
	ReplicationSnapshot getReplicationSnapshot() {
		return this.snapshot;
	}
	
	/*
	 * For debugging/yielding
	 */
	Unit debug() { debug = debug + 1; }
	
	Bool isShutdownRequested() {
		return shutDown;
	}
	
	Unit requestShutDown() {
		this.shutDown = True;
	}

	SyncServerClientCoordinator getCoordinator() {
		await coordinator != null;
		return this.coordinator;
	}
	
	SyncServerAcceptor getAcceptor() {
		await acceptor != null;
		return this.acceptor;
	}
	

}

/*
 * A simple model of a database mimicking 
 * a sequence of updates of files
 */
[Plain] class DataBaseImpl(Map<CheckPoint, Map<FileId,FileContent>> db) 
implements ServerDataBase, ClientDataBase {
	
	Int count = 0; //for debug
	
	CheckPoint ccp = -1;
	Set<CheckPoint> checkPoints = keys(db);
	
	// Begin with the root location (id = 0)
	Directory rootPath = rootDir();

	// ClientDataBase
	[Atomic] Bool prepareReplicationItem(CheckPoint p) {
		Bool result = False;
		if (! contains(checkPoints,p)) {
			checkPoints = insertElement(checkPoints, p);
			ccp = p;
			result = True;
		}
		return result;
	}
	
	[Atomic] Bool advancedCheckPoint() {
		Bool result = False;
		if (hasNext(checkPoints)) {
			Pair<Set<CheckPoint>,CheckPoint> nt = next(checkPoints);
			checkPoints = fst(nt);
			ccp = snd(nt);
			result = True;
		}
		return result;
	}
	
	[Atomic] Bool refresh(Bool update) {
		count = count + 1;
		Bool more = False;
		
		// advanced to the next check point;
		// only if update if required
		if (update) {
			more = this.advancedCheckPoint();
		}
		
		// if update is not required 
		// then update the filestore of the current checkpoint
		// else update the filestore of the next checkpoint
		if (!update || more) {
			Map<FileId,FileContent> updates = lookupUnsafe(db,ccp);
			this.rootPath = updateDirWithContents(this.rootPath,updates);
		}
		
		return (!update || more);
	}
	
	// Returns 0 if file not found.
	[Atomic] FileContent getContent(FileId fId) {
		Maybe<FileContent> result = Nothing;  
		if (fId == rootPath()) {
			result = Just(getFileContent(Right(rootPath)));
		} else {
			result = getFromEntryIn(rootPath,fId);
		}
		return fromJust(result);
	}
	
	[Atomic] Bool hasFile(FileId fId) {
		return hasEntriesIn(rootPath,fId);
	}
  
	[Atomic] Map<FileId,FileContent> checkPointFiles() {
		return lookupDefault(db,ccp,map[]);
	}
	
	// Updates file store
	// ClientDataBase
	[Atomic] Unit updateFile(FileId fId, FileSize size) {
		rootPath = updateDirWithFile(rootPath,file(fId,size));
	}
	
	[Atomic] Set<FileId> listCheckPointFiles() {
		Map<FileId,FileContent> checkPointFiles = this.checkPointFiles();
		return keys(checkPointFiles);
	}
	
	[Atomic] Set<FileId> listFiles() {
		Set<FileId> nieuw = getFileIdFromDir(rootPath);
		return nieuw;
	}
}

data State = 
	Start | WaitToBoot | Booting | 
	WaitToReplicate| WorkOnReplicate | End;
	
data Command =
	StartSnapShot | EndSnapShot | ListSchedule | 
	SearchSchedule | EndSearchFile | AppendSearchFile |
	ReceivePatternFile | 
	SkipFile | ContinueFile | OverwriteFile;
	
data JobType = Replication | Boot;

data ReplicationItemType =
	SearchReplicationDirectory | LogReplicationItem | ReplicationFilePattern;

type ClientId = Int;
	
// CSP set CheckPoint
// Java class com.fredhopper.search.fred.Checkpoint
// For Java method com.fredhopper.replication.server.item.SearchReplicationDirectory.isValid(String, long)
type CheckPoint = Int;

// Function on Maybe
def A fromJustDefault<A>(Maybe<A> m, A a) =
	case m { Just(j) => j; Nothing => a; };

// Functions on set of pairs
def Set<A> fsts<A, B>(Set<Pair<A, B>> ps) =
  case takeMaybe(ps) {
  	Nothing => set[];
  	Just(x) => insertElement(fsts(remove(ps, x)), fst(x));
  };
  
def Set<B> snds<A, B>(Set<Pair<A, B>> ps) =
  case takeMaybe(ps) {
  	Nothing => set[];
  	Just(x) => insertElement(snds(remove(ps, x)), snd(x));
  };
  
// Functions on data Command
def Bool isAppendCommand(Command c) = 
	case c {
		SkipFile => True;
		ContinueFile => True;
		OverwriteFile => True;
		_ => False;
	};

def Maybe<Int> hasValue(Map<Int,Command> m, Command b) =
	case m {
		EmptyMap => Nothing ;
    	InsertAssoc(Pair(x,y), tail) =>
    		case y == b {
    			True => Just(x);
    			False => hasValue(tail,b);
    		};
	};

def Map<Int,Command> commandMap() =
	map [
		Pair(200,ContinueFile),
		Pair(201,OverwriteFile),
		Pair(202,SkipFile),
		Pair(10,StartSnapShot),
		Pair(11,EndSnapShot),
		Pair(300,SearchSchedule),
		Pair(301,ListSchedule)
	];	

// convert a command to its corresponding integer	
def Int cmdToint(Command command) = 
	fromJust(hasValue(commandMap(),command));

// convert an integer to its corresponding command
def Command intTocmd(Int i) = lookupUnsafe(commandMap(),i);
	
// Insert 'a' at position i of list. 
def List<A> setAt<A>(List<A> list, A a, Int i) =
	case list {
		Nil => Nil;
		Cons(p,l) => 
			case i {
				0 => Cons(a,l);
				_ => Cons(p,setAt(l,a,i-1));
			 };
	};
	
def Bool setEquals<A>(Set<A> s, Set<A> t) = size(s) == size(t) && isSubset(s,t);


// String operations
// c must have length 1 currently
def List<String> split(String text, String c) = 
	case strlen(text) == 0 {
		True => Nil;
		False => split2(tailStr(text),c,Cons(headStr(text),Nil)); 
	};
	
def List<String> split2(String text, String c, List<String> result) =
	case strlen(text) == 0 {
		True => reverse(result);
		False => 
			let (String hd) = headStr(text) in
			case hd == c {
				True => split2(tailStr(text),c,Cons("",result));
				False => split2(tailStr(text),c,Cons(head(result) + hd,tail(result)));
			};
	};
	
def String headStr(String text) = substr(text,0,1);
def String tailStr(String text) = substr(text,1,strlen(text)-1);

// if list2 is a prefix of list1 
def Bool isPrefix<A>(List<A> list1, List<A> list2) =
	case list2 {
		Nil => True;
		Cons(l,ll) => 
			case list1 {
				Nil => False;
				Cons(m,mm) => (l == m) && isPrefix(mm,ll);
			};
	};
	
def List<String> stringToChar(String s) =
	let (Int l) = strlen(s) in
	case l == 0 {
		True => Nil;
		False => Cons(headStr(s),stringToChar(tailStr(s)));
	};
	
def Bool isPrefixText(String s1, String s2) = isPrefix(stringToChar(s2),stringToChar(s1));

def Bool filter(String pattern, String text) = isPrefixText(pattern,text);

// filters a set of strings against some pattern
def Set<String> filters(String pattern, Set<String> ts) =
	case takeMaybe(ts) {
		Nothing => set[];
		Just(l) => 
			case filter(pattern,l) {
				True => insertElement(filters(pattern,remove(ts, l)), l);
				False => filters(pattern,remove(ts, l));
			};
	};

[TypeAnnotation]
data VarType = Adds | Modifies;

// test data 
type TestData = Map<CheckPoint,Map<FileId,FileContent>>;

// CSP set FileId 
// Used for identifying the file to be replicated
type FileId = String;

// CSP set FileSize
// Java method java.io.File.length()
// Used for identifying the state of the client-side file 
type FileSize = Int;

// CSP name type File
type File = Pair<FileId,FileContent>;
type Directory = Pair<FileId,FileContent>;

// CSP name type Item
// Java class com.fredhopper.replication.server.item.ServerReplicationItem
type ReplicationItem = Pair<CheckPoint,Set<File>>;

// A File system structure
// internally file entry is organised hierarchically
// e.g. file 123 is organised 1/2/123 where 1 and 2 are directories
// default root directory id is 0 
// This will be extended once we allowed file ids as strings like "12/34/56".
type FileEntry = Map<FileId,FileContent>;

// Java com.fredhopper.replication.server.SyncServerSchedule
data Schedule = 
	  SearchItem(FileId) | //top level directory
	  FileItem(FileId,String) | //top level directory, pattern, checkpoint
	  LogItem(FileId); //for now log item is the same as search item

def Bool isSearchItem(Schedule s) = case s { SearchItem(_) => True; _ => False; };
def Bool isFileItem(Schedule s) = case s { FileItem(_,_) => True; _ => False; };
def Bool isLogItem(Schedule s) = case s { LogItem(_) => True; _ => False; };

def Either<FileId,Pair<FileId,String>> item(Schedule s) = 
	case s { 
		SearchItem(i) => Left(i); 
		FileItem(i,r) => Right(Pair(i,r));
		LogItem(i) => Left(i); 
	};

// a set of schedules
type ServerSchedule = Set<Schedule>;

// seems cannot use type synonym Either
data FileContent = Content(FileSize) | Entries(FileEntry); 

// if id1 is an ancester of id2
def Bool isAncester(FileId id1, FileId id2) = 
	isPrefix(deroot(split(id2,fileSep())),deroot(split(id1,fileSep()))); 
	 
def List<String> deroot(List<String> path) =
	let (FileId r) = rootPath() in case path { Cons(r,ps) => ps; _ => path; };

def File file(FileId i, FileSize s) = Pair(i,Content(s));
def Directory rootDir() = emptyDir(rootPath());
def Directory emptyDir(FileId i) = Pair(i,Entries(map[]));
def Directory dir(FileId i, FileEntry e) = Pair(i,Entries(e));

def String fileSep() = "/";
def FileId rootPath() = "root";
def Bool isFile(FileContent c) = case c { Content(_) => True; _ => False; };
def Bool isDirectory(FileContent c) = !isFile(c);

// partial
def FileSize content(FileContent c) = case c { Content(s) => s; };
def FileSize fileContent(File f) = content(snd(f));

// partial
def FileEntry entries(FileContent c) = case c { Entries(fs) => fs; };
def FileEntry dirContent(Directory f) = entries(snd(f));
	
def FileId getFileId(Either<File,Directory> f) =
	case f {
		Left(Pair(id,_)) => id;
		Right(Pair(id,_)) => id;
	};

def FileContent getFileContent(Either<File,Directory> f) =
	case f {
		Left(Pair(_,s)) => s;
		Right(Pair(_,fs)) => fs;
	};
	
def Either<File,Directory> makeContent(Pair<FileId,FileContent> content) =
	case isFile(snd(content)) {
		True => Left(content);
		False => Right(content);
	};

// given a/b and c returns a/b/c
def FileId makePath(FileId dir, FileId f) = dir + fileSep() + f;
def FileId makePaths(List<String> fs) = 
	case fs {
		Nil => "";
		Cons(f,Nil) => f;
		Cons(f,gs) => f + fileSep() + makePaths(gs);
	};

// given a/b/c returns (a/b,c)
def Pair<FileId,FileId> splitFileId(FileId f) = Pair(dirName(f),fileName(f));

// given a/b/c returns c
def FileId fileName(FileId f) = head(reverse(split(f,fileSep())));

// given a/b/c returns a/b
def FileId dirName(FileId f) = makePaths(reverse(tail(reverse(split(f,fileSep())))));	

// get fully qualified file ids from the suppied directory recursively
def Set<FileId> getFileIdFromDir(Directory d) = 
	case snd(d) { 
		Entries(e) => 
			case fst(d) == rootPath() {
				True => getFileIdFromEntries1(e);
				False => getFileIdFromEntries(fst(d),e);
			};
	};
	
def Set<FileId> getFileIdFromEntries1(FileEntry fe) =
	case fe {
		EmptyMap => set[];
		InsertAssoc(Pair(i,c),fs) => 
			case isFile(c) {
				True => insertElement(getFileIdFromEntries1(fs), i);
				False => union(getFileIdFromEntries(i,entries(c)),getFileIdFromEntries1(fs));
			};
	};
	
def Set<FileId> getFileIdFromEntries(FileId id, FileEntry fe) =
	case fe {
		EmptyMap => set[];
		InsertAssoc(Pair(i,c),fs) => 
			case isFile(c) {
				True => insertElement(getFileIdFromEntries(id,fs), makePath(id,i));
				False => union(getFileIdFromEntries(makePath(id,i),entries(c)),getFileIdFromEntries(id,fs));
			};
	};
	
def Bool hasEntriesIn(Directory d, FileId id) = case snd(d) { Entries(e) => hasEntry(e,id); };
def Bool hasEntry(FileEntry f, FileId id) = isJust(findFromEntry(f,id));

// find either a file or a directory (if it exists) given
// the file name (suffix of a fully qualified path)
def Maybe<Either<File,Directory>> findFromEntryIn(Directory d, FileId id) = 
	case snd(d) { Entries(e) => findFromEntry(e,id); };

// find either a file or a directory (if it exists) given
// the file name (suffix of a fully qualified path)
def Maybe<Either<File,Directory>> findFromEntry(FileEntry f, FileId id) =
    // TODO: use new 'lookup'
	case contains(keys(f),id) {
		True =>
			case lookupUnsafe(f,id) {
				Content(s) => makeMaybeEitherValue(True,id,Content(s)); // leaf
				Entries(e) => makeMaybeEitherValue(False,id,Entries(e)); // leaf
			};
		False => 
			case f {
				InsertAssoc(Pair(i,Content(_)),fm) => findFromEntry(fm,id);
				InsertAssoc(Pair(i,Entries(g)),fm) => 
						case findFromEntry(g,id) {
							Nothing => findFromEntry(fm,id); //next path
							r => qualify(r,i);
						};
				EmptyMap => Nothing; // end of listing
			};	 
	};
	
// prefix id of 'r' with 'path'
def Maybe<Either<File,Directory>> qualify(Maybe<Either<File,Directory>> r, FileId path) =
	case r {
		Just(h) =>
			let (FileId hi) = makePath(path,getFileId(h)) in
			let (FileContent hc) = getFileContent(h) in
			case h {
				Left(_) => makeMaybeEitherValue(True,hi,hc);
				Right(_) => makeMaybeEitherValue(False,hi,hc);
			}; 
		Nothing => Nothing;
	};
	
def Maybe<Either<File,Directory>> makeMaybeEitherValue(Bool isfile, FileId id, FileContent c) =
	case isfile {
		True => Just(Left(Pair(id,c)));
		_ => Just(Right(Pair(id,c)));
	};
	
def Bool hasQualifiedEntriesIn(Directory d, FileId qualified) = 
	case snd(d) { Entries(e) => hasQualifiedEntry(e,qualified); };
	
def Bool hasQualifiedEntry(FileEntry f, FileId qualified) = isJust(getFromEntry(f,qualified));

def Maybe<FileContent> getFromEntryIn(Directory d, FileId qualified) = 
	case snd(d) { 
		Entries(e) => 
			case fst(d) == rootPath() {
				True => getFromEntry(e,qualified); //root id '0' is disregard
				_ => getFromEntry(map[d],qualified); 
			};
	};

// get the content (if it exists) from a fully qualified path
def Maybe<FileContent> getFromEntry(FileEntry entry, FileId qualified) = 
	let (List<String> paths) = split(qualified,fileSep()) in
	case length(paths) > 0 {
		True => 
		    // TODO: use new 'lookup'
			case contains(keys(entry),head(paths)) {
				True => 
					let (FileContent cc) = lookupUnsafe(entry,head(paths)) in
					case length(tail(paths)) {
						0 => Just(cc); // at node
						_ => case cc {
								// qualified is of form 'a/b/...' 
								// but at this level 'a' is a file and not a directory
								Content(_) => Nothing; 
								// else we are on the right track
								// go to the subdirectory
								Entries(e) => getFromEntry(e,makePaths(tail(paths)));
							};  
					};
				False => Nothing; //not found
			};
		False => Nothing; 
	};
	
def Directory updateDirWithContent(Directory d, FileId i, FileContent c) = updateDirWith(d,makeContent(Pair(i,c)));
def Directory updateDirWithContents(Directory d, Map<FileId,FileContent> contents) =
	case contents {
		EmptyMap => d;
		InsertAssoc(Pair(i,c),cs) => updateDirWithContents(updateDirWithContent(d,i,c),cs);
	};

// Update a directory with a file
def Directory updateDirWithFile(Directory d, File f) = updateDirWith(d,Left(f));

// Update a directory with a directory
def Directory updateDirWithDir(Directory d, Directory f) = updateDirWith(d,Right(f));

// Update a directory with either a directory or a file
def Directory updateDirWith(Directory d, Either<File,Directory> f) = case snd(d) { Entries(e) => Pair(fst(d),Entries(updateFile(e,f))); };

def FileEntry updateFile(FileEntry fe, Either<File,Directory> f) = 
	updateFile1(fe,getFileContent(f),deroot(split(getFileId(f),fileSep())));
	
def FileEntry updateFile1(FileEntry fe, FileContent c, List<String> path) =
	case path {
		Nil => fe;
		Cons(p,Nil) => put(fe,p,c);
		Cons(p,ps) =>
		    // TODO: use new 'lookup'
			case contains(keys(fe),p) {
				True => 
					case lookupUnsafe(fe,p) {
						Entries(dc) => put(fe,p,Entries(updateFile1(dc,c,ps))); //dir
						_ => put(fe,p,create(ps,c));  //file 
					};
				False => put(fe,p,create(ps,c));
			}; 
	}; 

def FileContent create(List<String> path, FileContent c) =
	case c {
		Content(s) => 
			case path {
				Cons(p,Nil) => Entries(map[Pair(p,c)]);
				Cons(p,ps) => Entries(map[Pair(p,create(ps,c))]);
			};
		_ => c;
	};
	

/*
 * Common operations to all data base:
 * 1. get the file size (content) of a file (id)
 * 2. list all files in the file store 
 */
interface DataBase {
 	[Atomic] FileContent getContent(FileId fId);
 	[Atomic] Bool hasFile(FileId fId);
  	[Atomic] Set<FileId> listFiles();
}

/*
 * A data base on the server has a readonly internal
 * data base and can peform the following: 
 * 1. refresh data base
 * 2. list file (ids) of the current checkpoint
 */
interface ServerDataBase extends DataBase {
  	[Atomic] Bool refresh(Bool updateFileStore);
  	[Atomic] Set<FileId> listCheckPointFiles();
}

/*
 * A client data base cannot be refreshed
 * but can perform the following:
 * 1. prepare a new client replication item;
 * 2  update both internal data base and file store with new files 
 */
interface ClientDataBase extends DataBase {
  	[Atomic] Bool prepareReplicationItem(CheckPoint cp);
  	[Atomic] Unit updateFile(FileId fId, FileSize size);
}

{ 
	new local Main();
}
