grammar org.xtext.example.mydsl.Abs 

generate abs "http://www.xtext.org/example/mydsl/Abs"

Model:
	compilation_unit+=Compilation_unit*
;

Compilation_unit:{Compilation_unit}
	(module_decl+=Module_decl)*
	(delta_decl+=Delta_decl)*
	(update_decl+=Update_decl)* 
	(productline_decl+=Productline_decl)?
	(product_decl+=Product_decl)* 
	('root' feature_decl+=Feature_decl|'extension' fextension+=Fextension)*
;

Delta_decl:'delta' type=TYPE_IDENTIFIER
	('('p+=Delta_param(',' p+=Delta_param)*')')? ';' (delta_access+=Delta_access)*
	(module_modifier+=Module_modifier)*
;

Delta_param: param_decl=Param_decl
	| (qualified_type_identifier+=QUALIFIED_TYPE_IDENTIFIER has_condition=Has_condition)
;

Has_condition:'hasfield' f=Field_decl
	| 'hasMethod' m=Methodsig
	| 'hasInterface' i=INTERFACE_NAME
;

Field_decl:
	annotation+=Annotation type_use=Type_use identifier=IDENTIFIER ('=' pure_exp=Pure_exp)? ';'
;
Delta_access:'uses' qualified_type_identifier=QUALIFIED_TYPE_IDENTIFIER ';'
;

Module_modifier:functional_modifier=Functional_modifier
	| oo_modifier=OO_modifier
	| namespace_modifier=Namespace_modifier
;

Functional_modifier:'adds' function_decl=Function_decl
	| 'adds' datatype_decl=Datatype_decl
	| 'adds' typesyn_decl=Typesyn_decl
	| 'modifies' Datatype_decl 
;

OO_modifier:'adds' class_decl=Class_decl
	| 'removes' 'class' qualified_type_identifier=QUALIFIED_TYPE_IDENTIFIER ';'
	| 'modifies' 'class' n=QUALIFIED_TYPE_IDENTIFIER 
		('adds' ia+=INTERFACE_NAME (',' ia+=INTERFACE_NAME)*)?
		('removes' ir+=INTERFACE_NAME (',' ir+=INTERFACE_NAME)*)?
		'{' ((class_modifier_fragment+=Class_modifier_fragment)*) '}'
	| 'adds' interface_decl=Interface_decl
	| 'removes' 'interface' qualified_type_identifier=QUALIFIED_TYPE_IDENTIFIER ';' 
	| 'modifies' 'interface' qualified_type_identifier=QUALIFIED_TYPE_IDENTIFIER
	  '{' (interface_modifier_fragment+=Interface_modifier_fragment)* '}' 
;

Class_modifier_fragment:'adds' field_decl=Field_decl
	| 'removes' field_decl=Field_decl
	| trait_oper=Trait_oper
;

Interface_modifier_fragment:'adds' methodsig=Methodsig
	|'removes' methodsig=Methodsig
;

Namespace_modifier:'adds' module_import=Module_import
	| 'adds' module_import=Module_export
;




Paramlist:{Paramlist}'('(param_decl+=Param_decl(',' param_decl+=Param_decl)*)?')'
;

Param_decl:(annotation+=Annotation)* type_exp=Type_exp identifier=IDENTIFIER
;

Update_decl:'stateupdate' type=TYPE_IDENTIFIER ';' (object_update+=Object_update)*
;

Object_update:'objectupdate' QUALIFIED_TYPE_IDENTIFIER '{' 'await' guard=Guard ';' 
	(update_preamble_declaration+=Update_preamble_declaration)*
	(pre+=Object_update_assign_stmt)*
	'classupdate' ';'
	(post+=Object_update_assign_stmt)* '}'
;

Object_update_assign_stmt:var_or_field_ref=Var_or_field_ref '=' exp=Exp ';'
;

Var_or_field_ref:('this' '.')? identifier=IDENTIFIER
;

Update_preamble_declaration:type_exp=Type_exp identifier=IDENTIFIER
;


Productline_decl:'productline' type=TYPE_IDENTIFIER ';' 
	'features' feature+=Feature(',' feature+=Feature)* ';'
	(delta_clause+=Delta_clause)*
;

Delta_clause:'delta' deltaspec+=Deltaspec 
	(after_condition+=After_condition)? (from_condition+=From_condition)? 
	(when_condition+=When_condition)? ';'
;

Deltaspec:type=TYPE_IDENTIFIER('(' deltaspec_param+=Deltaspec_param (',' deltaspec_param+=Deltaspec_param)* ')')?
;

Deltaspec_param: type=TYPE_IDENTIFIER '.' identifier=IDENTIFIER
	|intlteral=INTLITERAL
	|type=TYPE_IDENTIFIER
;

After_condition:'after' delta_id+=TYPE_IDENTIFIER(',' delta_id+=TYPE_IDENTIFIER)*
;

From_condition:'from' application_condition+=Application_condition	
;

When_condition: ('when'|'to') application_condition+=Application_condition 	
;

Application_condition:(negation=NEGATION|negation_creol=NEGATION_CREOL) application_condition+=Application_condition
	|App_condition ({Operation.left=current} Op=operation right=Application_condition)?
;

App_condition returns Application_condition:
	'('Application_condition')'|Feature
;


Product_decl:'product' product_name=TYPE_IDENTIFIER(
	'('(feature+=Feature(','(feature+=Feature))*)?')'
	('{'(product_reconfiguration+=Product_reconfiguration)*'}'|';')
	|'=' product_expr+=Product_expr';'
);

Feature:
	feature_name=TYPE_IDENTIFIER (p='\'')?('{' attr_assignment+=Attr_assignment(','(attr_assignment+=Attr_assignment))?)
;

Attr_assignment:attr_assignment=TYPE_IDENTIFIER '=' (i=INTLITERAL|b=TYPE_IDENTIFIER|s=STRINGLITERAL);

Product_reconfiguration:product=TYPE_IDENTIFIER 'delta' delta_id+=TYPE_IDENTIFIER(',' delta_id+=TYPE_IDENTIFIER)*
	'stateupdate' update=TYPE_IDENTIFIER ';'
;

Product_expr:'{' feature+=Feature(',' feature+=Feature)* '}'|
	product_expression ({Operation.left=current} Op=operation right=Product_expr)?|
	type_identifier=TYPE_IDENTIFIER|'('product_expression')'
;
product_expression returns Product_expr:
	'('Product_expr')'|value=INTLITERAL
;
operation:ANDAND|OROR|MINUS|NEGATION|NEGATION_CREOL|EQEQ|NOTEQ|GTEQ|LTEQ|DIV|MOD|MULT|PLUS|LT|GT
;

Fextension:fextension_name=TYPE_IDENTIFIER '{'(feature_decl_group+=Feature_decl_group)?
	((feature_declaration_attribute+=Feature_decl_attribute)|(feature_declaration_constraint+=Feature_decl_constraint))*'}'
	
;

Feature_decl:feature_decl=TYPE_IDENTIFIER
	('{' (feature_declaration_group+=Feature_decl_group)?((feature_declaration_attribute+=Feature_decl_attribute)
		 |(feature_declaration_constraint+=Feature_decl_constraint ))*'}')?
;

Feature_decl_group:'group'(oneof='oneof'|allof='allof'|
	'['lower_intliteral=INTLITERAL'..'(upper_intliteral=INTLITERAL|s='*')']')
	'{'(feature_node+=Fnode)(',' feature_node+=Fnode)*'}';
	
Fnode: opt= ('opt')? feature_decl=Feature_decl;

Feature_decl_attribute: type=TYPE_IDENTIFIER identifier=IDENTIFIER 'in' '{' is+=Boundary_val(',' is+=Boundary_val)* '}'
	|type=TYPE_IDENTIFIER identifier=IDENTIFIER 'in' '[' l=Boundary_int '..' u=Boundary_int ']' ';'
	|type=TYPE_IDENTIFIER identifier=IDENTIFIER '[' l=Boundary_int '..' u=Boundary_int ']' IDENTIFIER ';'
	|type=TYPE_IDENTIFIER identifier=IDENTIFIER ';'
;

Feature_decl_constraint: ('ifin' ':')? Mexp=mexp ';'
	|'ifout' ':' Mexp=mexp ';'
	|'exclude' ':' type=TYPE_IDENTIFIER ';'
	|'require' ':' type=TYPE_IDENTIFIER ';'
;

//Incomplete
mexp: type=TYPE_IDENTIFIER '.' identifier=IDENTIFIER
	|type=TYPE_IDENTIFIER
	|intliteral=INTLITERAL
	|identifier=IDENTIFIER
	
;
Boundary_val: hyphen='-'? intliteral=INTLITERAL
;

Boundary_int:star='*'|Boundary_val
;

//main_block: annotations '{' stmt*'}';

Exp:eff_exp=Eff_exp | pure_exp=Pure_exp
;
Eff_exp:pure_exp=Pure_exp '.' 'get'
	|'new' l='local'? c=QUALIFIED_TYPE_IDENTIFIER '('pure_exp_list=Pure_exp_list ')'
	| a='await'? o=Pure_exp negation=NEGATION m=IDENTIFIER '('pure_exp_list=Pure_exp_list ')'
	| o=Pure_exp '.' m=IDENTIFIER '('pure_exp_list=Pure_exp_list ')'
	| ((d=TYPE_IDENTIFIER| c='core' ) '.')? 'original' '('pure_exp_list=Pure_exp_list ')'
;

Pure_exp:
	qualified_identifier=QUALIFIED_IDENTFIER '('pure_exp_list=Pure_exp_list')'
	| qualified_identifier=QUALIFIED_IDENTFIER '['pure_exp_list=Pure_exp_list']'
	| qualified_type_identifier=QUALIFIED_TYPE_IDENTIFIER ('('pure_exp_list=Pure_exp_list')')
	| Op=operation pure_exp=Pure_exp
	| pure_expression ({Operation.left=current} Op=operation right=Pure_exp)?
	| var_or_field_ref=Var_or_field_ref
	| intliteral=INTLITERAL
	| {Pure_exp}'this'
	| {Pure_exp}'null'
	| 'if' c=Pure_exp 'then' l=Pure_exp 'else' r=Pure_exp
	| 'case' c=Pure_exp '{' (casebranch+=Casebranch)* '}'
	| 'let' '(' type_use=Type_use identifier=IDENTIFIER ')' '=' i=Pure_exp 'in' b=Pure_exp
;

pure_expression returns Pure_exp:
	'('pure_exp=Pure_exp')'
;

Casebranch: pattern=Pattern implies=IMPLIES pure_exp=Pure_exp ';'
;

Pattern:{Pattern} '_' 
	|intliteral=INTLITERAL
	|stringliteral=STRINGLITERAL
	|identifier=IDENTIFIER
	|qualified_type_identifier=QUALIFIED_TYPE_IDENTIFIER 
	('('(pattern+=Pattern(',' pattern+=Pattern)*)? ')')
;

Pure_exp_list:{Pure_exp_list}(pure_exp+=Pure_exp(',' pure_exp+=Pure_exp)*)?
;

List_literal:'[' pure_exp+=Pure_exp(','pure_exp+=Pure_exp)* ']'
	
;

Type_exp:n=QUALIFIED_TYPE_IDENTIFIER (lt=LT p+=Type_use (',' p+=Type_use)* gt=GT)?
;

Type_use:annotations=Annotations n=QUALIFIED_TYPE_IDENTIFIER
	(lt=LT p+=Type_use (',' p+=Type_use)* gt=GT)?
;

Annotations:{Annotations}('['al+=Annotation(',' al+=Annotation)*']')*
;

Annotation:(l=Type_use ':')? r=Pure_exp
;

Stmt:annotations=Annotations type_exp=Type_exp identifier=IDENTIFIER ('=' exp=Exp)? ';'
	| annotations=Annotations var_or_field_ref=Var_or_field_ref '=' exp=Exp ';'
	| annotations=Annotations 'skip' ';'
	| annotations=Annotations 'return' exp=Exp ';'
	| annotations=Annotations 'assert' exp=Exp ';'
	| annotations=Annotations '{' (stmt+=Stmt)* '}'
	| annotations=Annotations 'if' '(' c=Pure_exp ')' l=Stmt ('else' r=Stmt)?
	| annotations=Annotations 'while' '(' c=Pure_exp ')' stmt+=Stmt
	| annotations=Annotations 'foreach' '(' i=IDENTIFIER 'in' l=Pure_exp')' stmt+=Stmt
	| annotations=Annotations 'try' b=Stmt 'catch'
	  (('{' (casestmtbranch+=Casestmtbranch)* '}')|casestmtbranch+=Casestmtbranch)('finally' f=Stmt)?
	| annotations=Annotations 'await' guard=Guard ';'
	| annotations=Annotations 'suspend' ';'
	| annotations=Annotations 'duration' '(' f=Pure_exp ',' t=Pure_exp ')' ';'
	| annotations=Annotations 'throw' pure_exp=Pure_exp ';'
	| annotations=Annotations 'die' pure_exp=Pure_exp ';'
	| annotations=Annotations 'movecogto' pure_exp=Pure_exp ';'
	| annotations=Annotations exp=Exp ';'
	| annotations=Annotations 'case' c=Pure_exp '{' (casestmtbranch+=Casestmtbranch)* '}'
;

Guard:var_or_field_ref=Var_or_field_ref '?'
	| 'duration' '(' min=Pure_exp ',' max=Pure_exp ')'
	| e=Pure_exp
	//| l+=Guard '&' r=Guard
;

Casestmtbranch:pattern=Pattern implies=IMPLIES stmt=Stmt
;

//DATATYPES
Datatype_decl:annotations=Annotations 'data' n=TYPE_IDENTIFIER
	(lt=LT p+=TYPE_IDENTIFIER (',' p+=TYPE_IDENTIFIER)* gt=GT)?
	('=' c+=Data_constructor('|' c+=Data_constructor)*)? ';'
;

Data_constructor:n=TYPE_IDENTIFIER
	('(' a+=Data_constructor_arg(',' a+=Data_constructor_arg)*')')?
;

Data_constructor_arg:type_use=Type_use (identifier=IDENTIFIER)? 
;

//TYPE SYNONYMS
Typesyn_decl:annotations=Annotations 'type' type=TYPE_IDENTIFIER '=' type_use=Type_use ';'
;

//EXCEPTIONS
Exception_decl:annotations=Annotations 'exception' n=TYPE_IDENTIFIER
	('('a+=Data_constructor_arg(',' a+=Data_constructor_arg)*')')? ';'
;

//FUNCTIONS
Function_decl:annotations=Annotations 'def' type_use=Type_use n=IDENTIFIER
	(lt=LT p+=TYPE_IDENTIFIER(',' p+=TYPE_IDENTIFIER)* gt=GT)? paramlist=Paramlist '=' 
	('builtin'|e=Pure_exp) ';' 	
;

//INTERFACES
Interface_decl:(annotation+=Annotation)* 'interface' type=TYPE_IDENTIFIER
	('extends' e+=INTERFACE_NAME (',' e+=INTERFACE_NAME)*)?
	'{' (methodsig+=Methodsig)* '}'
;

Methodsig:(annotation+=Annotation)* type_use=Type_use identifier=IDENTIFIER paramlist=Paramlist ';'
;

//CLASSSES
Class_decl:(annotation+=Annotation)* 'class' type=TYPE_IDENTIFIER (paramlist=Paramlist)?
	('implements' interface_name+=INTERFACE_NAME (',' interface_name+=INTERFACE_NAME)*)?
	'{'(field_decl+=Field_decl)* ('{' (stmt+=Stmt)* '}')?
	( 'recover' '{' (casestmtbranch+=Casestmtbranch)* '}' )?
	(trait_usage+=Trait_usage)* (method+=Method)* '}'
;

Method: (annotation+=Annotation)* type_use=Type_use identifier=IDENTIFIER paramlist=Paramlist
	'{' (stmt+=Stmt)*'}'
;

//MODULE DECLARATION
Module_decl:'module' qualified_type_identifier=QUALIFIED_TYPE_IDENTIFIER ';'
	(module_export+=Module_export)* (module_import+=Module_import)* (decl+=Decl)*
	(main_block=Main_block)? 
;

Main_block:{Main_block}(annotation+=Annotation)* '{'(stmt+=Stmt)*'}'
;

Module_export:{Module_export}'export' ( '*' | s+=ANY_IDENTIFIER (',' s+=ANY_IDENTIFIER)*)
	('from' f=QUALIFIED_TYPE_IDENTIFIER)? ';'
;

Module_import:'import' ( '*' 'from' f=QUALIFIED_TYPE_IDENTIFIER ';'
	|s+=ANY_IDENTIFIER (',' s+=ANY_IDENTIFIER)* 'from' f=QUALIFIED_TYPE_IDENTIFIER ';'
	|s+=ANY_IDENTIFIER (',' s+=ANY_IDENTIFIER)* ';' )
;

//TOP lEVEL DECLARATION
Decl:
	datatype_decl=Datatype_decl
	| function_decl=Function_decl
	| typesyn_decl=Typesyn_decl
	| exception_decl=Exception_decl
	| interface_decl=Interface_decl
	| class_decl=Class_decl
	| trait_decl=Trait_decl
;

Trait_decl:'trait' type=TYPE_IDENTIFIER '=' trait_expr=Trait_expr 
;

Trait_expr:{Trait_expr}'{' (method+=Method)* '}'
	| method+=Method
	| type=TYPE_IDENTIFIER
	//| trait_expr=Trait_expr trait_oper=Trait_oper
;

Trait_oper:{Trait_oper}'removes' methodsig=Methodsig
	| {Trait_oper}'removes' '{' (method+=Method)*'}' 
	//| 'adds' trait_expr=Trait_expr
	//| 'modifies' trait_expr=Trait_expr
;

Trait_usage:'uses' trait_expr=Trait_expr ';' 
;


	

	


// Comments and whitespace
terminal ML_COMMENT  : '/*' -> '*/';
terminal SL_COMMENT  : '//' !('\n'|'\r')* ('\r'? '\n')?;

terminal WS: (' '|'\t'|'\r'|'\n')+;

terminal STR_ESC:
	'\\'('\\'|'"')
;
terminal STRINGLITERAL:
	'"'(STR_ESC|NEGATION_CREOL('\\'|'"'|'\r'|'\n'))*'"'
;

// Identifier
terminal SMALLLETTER:
	'a'..'z'
;
terminal CAPITALLETTER:
	'A'..'Z'
;

terminal DIGIT:
	'0'..'9'
;
terminal INTLITERAL:
	DIGIT(DIGIT)*
;

terminal IDENTIFIER:
	(SMALLLETTER)(SMALLLETTER|'_'|DIGIT)*
;

terminal TYPE_IDENTIFIER:
	(CAPITALLETTER)(SMALLLETTER|'_'|DIGIT)*
;
terminal QUALIFIED_IDENTFIER:
	TYPE_IDENTIFIER('.'IDENTIFIER)*
;
terminal QUALIFIED_TYPE_IDENTIFIER:
	(TYPE_IDENTIFIER'.')* TYPE_IDENTIFIER
;
terminal NEGATION_CREOL:
	'~'
;
terminal NEGATION:
	'!'
;
terminal MINUS:
	' - '
;
terminal MULT:
	' * '
;
terminal DIV:
	' / '
;
terminal MOD:
	'%'
;
terminal PLUS:
	'+'
;
terminal LTEQ:
	'<='
;
terminal GTEQ:
	'>='
;
terminal LT:
	'<'
;
terminal GT:
	'>'
;
terminal ANDAND:
	'&&'
;
terminal OROR:
	'||'
;
terminal EQEQ:
	'=='
;
terminal NOTEQ:
	'!='
;
terminal IMPLIES:
	'->'
;
terminal ANY_IDENTIFIER:
	QUALIFIED_TYPE_IDENTIFIER|QUALIFIED_IDENTFIER
;
terminal INTERFACE_NAME:
	QUALIFIED_TYPE_IDENTIFIER
;

;